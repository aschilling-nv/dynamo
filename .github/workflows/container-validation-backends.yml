# SPDX-FileCopyrightText: Copyright (c) 2024-2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

name: Docker Build and Test

on:
  push:
    branches:
      - main
      - "pull-request/[0-9]+"
      - release/*.*.*

concurrency:
    group: ${{ github.workflow }}-build-test-${{ github.ref_name || github.run_id }}
    cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

jobs:
  changed-files:
    runs-on: ubuntu-latest
    outputs:
      has_code_changes: ${{ steps.filter.outputs.has_code_changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
      - name: Check for changes
        uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36  # v3.0.2
        id: filter
        with:
          filters: .github/filters.yaml

  backend-status-check:
    runs-on: ubuntu-latest
    needs: [vllm, sglang, trtllm]
    if: always()
    steps:
      - name: "Check all dependent jobs"
        run: |
          echo '${{ toJson(needs) }}' | jq -e 'to_entries | map(.value.result) | all(. as $result | ["success", "skipped"] | any($result == .))'

  vllm:
    needs: changed-files
    if: needs.changed-files.outputs.has_code_changes == 'true'
    outputs:
      build-duration-sec: ${{ steps.build-end.outputs.build-duration-sec }}
      image-size-bytes: ${{ steps.capture-metrics.outputs.image-size-bytes }}
      image-size-mb: ${{ steps.capture-metrics.outputs.image-size-mb }}
      build-start-time: ${{ steps.build-start.outputs.build-start-time }}
      build-end-time: ${{ steps.build-end.outputs.build-end-time }}
      cache-hit-rate: ${{ steps.capture-metrics.outputs.cache-hit-rate }}
      sccache-working: ${{ steps.capture-metrics.outputs.sccache-working }}
      sccache-requests: ${{ steps.capture-metrics.outputs.sccache-requests }}
      framework: ${{ steps.capture-metrics.outputs.framework }}
      target: ${{ steps.capture-metrics.outputs.target }}
    strategy:
      fail-fast: false
      matrix:
        platform:
          - { arch: amd64, runner: gpu-l40-amd64 }
          - { arch: arm64, runner: cpu-arm-r8g-4xlarge }
    name: vllm (${{ matrix.platform.arch }})
    runs-on: ${{ matrix.platform.runner }}
    steps:
      - name: Checkout code
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
      - name: Capture Build Start Time
        id: build-start
        run: |
          BUILD_START_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "build-start-time=${BUILD_START_TIME}" >> $GITHUB_OUTPUT
          echo "🕐 Build started at: ${BUILD_START_TIME}"

      - name: Build Container
        id: build-image
        uses: ./.github/actions/docker-build
        with:
          framework: vllm
          target: runtime
          platform: 'linux/${{ matrix.platform.arch }}'
          ngc_ci_access_token: ${{ secrets.NGC_CI_ACCESS_TOKEN }}
          ci_token: ${{ secrets.CI_TOKEN }}
          aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          sccache_s3_bucket: ${{ secrets.SCCACHE_S3_BUCKET }}
          aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Capture Build End Time
        id: build-end
        run: |
          BUILD_END_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          BUILD_START_TIME="${{ steps.build-start.outputs.build-start-time }}"
          
          # Calculate duration
          START_EPOCH=$(date -d "$BUILD_START_TIME" +%s)
          END_EPOCH=$(date -d "$BUILD_END_TIME" +%s)
          BUILD_DURATION_SEC=$((END_EPOCH - START_EPOCH))
          
          echo "build-end-time=${BUILD_END_TIME}" >> $GITHUB_OUTPUT
          echo "build-duration-sec=${BUILD_DURATION_SEC}" >> $GITHUB_OUTPUT
          echo "🕐 Build ended at: ${BUILD_END_TIME}"
          echo "⏱️  Build duration: ${BUILD_DURATION_SEC} seconds"
      - name: Docker Tag and Push
        uses: ./.github/actions/docker-tag-push
        with:
          local_image: ${{ steps.build-image.outputs.image_tag }}
          push_tag: ai-dynamo/dynamo:${{ github.sha }}-vllm-${{ matrix.platform.arch }}
          # OPS-1145: Switch aws_push to true
          aws_push: 'false'
          azure_push: 'true'
          aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          azure_acr_hostname: ${{ secrets.AZURE_ACR_HOSTNAME }}
          azure_acr_user: ${{ secrets.AZURE_ACR_USER }}
          azure_acr_password: ${{ secrets.AZURE_ACR_PASSWORD }}
      
      # Capture build metrics for the "Build and Test - vllm" job
      - name: Capture Build Metrics
        id: capture-metrics
        if: ${{ matrix.platform.arch == 'amd64' }}  # Only capture metrics for amd64 build
        run: |
          echo "📊 Capturing build metrics for vllm..."
          
          # Create metrics directory
          mkdir -p build-metrics
          
          # Get accurate build timing from the timing steps
          BUILD_START_TIME="${{ steps.build-start.outputs.build-start-time }}"
          BUILD_END_TIME="${{ steps.build-end.outputs.build-end-time }}"
          BUILD_DURATION_SEC="${{ steps.build-end.outputs.build-duration-sec }}"
          
          echo "🕐 Build timing (from capture steps):"
          echo "  Start: ${BUILD_START_TIME}"
          echo "  End: ${BUILD_END_TIME}"
          echo "  Duration: ${BUILD_DURATION_SEC} seconds"
          
          # Get image size using docker inspect
          IMAGE_TAG="${{ steps.build-image.outputs.image_tag }}"
          if [ -n "$IMAGE_TAG" ]; then
            IMAGE_SIZE_BYTES=$(docker image inspect "$IMAGE_TAG" --format='{{.Size}}' 2>/dev/null || echo "0")
            IMAGE_SIZE_MB=$((IMAGE_SIZE_BYTES / 1024 / 1024))
            echo "📦 Image size: ${IMAGE_SIZE_MB} MB (${IMAGE_SIZE_BYTES} bytes)"
          else
            IMAGE_SIZE_BYTES=0
            IMAGE_SIZE_MB=0
            echo "⚠️  No image tag available"
          fi
          
          # Check what outputs are actually available from docker-build action
          echo "🔍 Available docker-build outputs:"
          echo "  image_tag: '${{ steps.build-image.outputs.image_tag }}'"
          echo "  cache-hit-rate: '${{ steps.build-image.outputs.cache-hit-rate }}'"
          echo "  sccache-working: '${{ steps.build-image.outputs.sccache-working }}'"
          echo "  sccache-requests: '${{ steps.build-image.outputs.sccache-requests }}'"
          
          # Get cache metrics from outputs (with fallbacks)
          CACHE_HIT_RATE="${{ steps.build-image.outputs.cache-hit-rate }}"
          SCCACHE_WORKING="${{ steps.build-image.outputs.sccache-working }}"
          SCCACHE_REQUESTS="${{ steps.build-image.outputs.sccache-requests }}"
          
          # Try to get sccache stats if the action didn't provide them
          if [ -z "$CACHE_HIT_RATE" ] || [ "$CACHE_HIT_RATE" = "0" ]; then
            echo "🔍 Attempting to get sccache stats..."
            if command -v sccache >/dev/null 2>&1; then
              SCCACHE_STATS=$(sccache --show-stats 2>/dev/null || echo "")
              if [ -n "$SCCACHE_STATS" ]; then
                echo "📊 sccache stats:"
                echo "$SCCACHE_STATS"
                
                # Parse sccache stats (this is a basic parser, may need adjustment)
                CACHE_HITS=$(echo "$SCCACHE_STATS" | grep -i "cache hits" | grep -o '[0-9]\+' | head -1 || echo "0")
                CACHE_MISSES=$(echo "$SCCACHE_STATS" | grep -i "cache misses" | grep -o '[0-9]\+' | head -1 || echo "0")
                TOTAL_REQUESTS=$((CACHE_HITS + CACHE_MISSES))
                
                if [ "$TOTAL_REQUESTS" -gt 0 ]; then
                  CACHE_HIT_RATE=$((CACHE_HITS * 100 / TOTAL_REQUESTS))
                  SCCACHE_WORKING="true"
                  SCCACHE_REQUESTS="$TOTAL_REQUESTS"
                fi
              fi
            else
              echo "⚠️  sccache not available in PATH"
            fi
          fi
          
          # Set defaults for missing values
          CACHE_HIT_RATE="${CACHE_HIT_RATE:-0}"
          SCCACHE_WORKING="${SCCACHE_WORKING:-false}"
          SCCACHE_REQUESTS="${SCCACHE_REQUESTS:-0}"
          
          echo "📊 Final metrics:"
          echo "  Build start: ${BUILD_START_TIME}"
          echo "  Build end: ${BUILD_END_TIME}"
          echo "  Duration: ${BUILD_DURATION_SEC} seconds"
          echo "  Cache hit rate: ${CACHE_HIT_RATE}%"
          echo "  sccache working: ${SCCACHE_WORKING}"
          echo "  sccache requests: ${SCCACHE_REQUESTS}"
          
          # Create metrics JSON file
          cat > build-metrics/metrics.json << EOF
          {
            "framework": "vllm",
            "target": "runtime",
            "platform": "linux/${{ matrix.platform.arch }}",
            "image_size_bytes": ${IMAGE_SIZE_BYTES},
            "image_size_mb": ${IMAGE_SIZE_MB},
            "build_start_time": "${BUILD_START_TIME}",
            "build_end_time": "${BUILD_END_TIME}",
            "build_duration_sec": ${BUILD_DURATION_SEC},
            "cache_hit_rate": ${CACHE_HIT_RATE},
            "sccache_working": "${SCCACHE_WORKING}",
            "sccache_requests": ${SCCACHE_REQUESTS}
          }
          EOF
          
          echo "📁 Build metrics saved:"
          cat build-metrics/metrics.json
          
          # Set outputs for job-level access
          echo "build-duration-sec=${BUILD_DURATION_SEC}" >> $GITHUB_OUTPUT
          echo "image-size-bytes=${IMAGE_SIZE_BYTES}" >> $GITHUB_OUTPUT
          echo "image-size-mb=${IMAGE_SIZE_MB}" >> $GITHUB_OUTPUT
          echo "build-start-time=${BUILD_START_TIME}" >> $GITHUB_OUTPUT
          echo "build-end-time=${BUILD_END_TIME}" >> $GITHUB_OUTPUT
          echo "cache-hit-rate=${CACHE_HIT_RATE}" >> $GITHUB_OUTPUT
          echo "sccache-working=${SCCACHE_WORKING}" >> $GITHUB_OUTPUT
          echo "sccache-requests=${SCCACHE_REQUESTS}" >> $GITHUB_OUTPUT
          echo "framework=vllm" >> $GITHUB_OUTPUT
          echo "target=runtime" >> $GITHUB_OUTPUT

      # Upload build metrics as artifact
      - name: Upload Build Metrics
        if: ${{ matrix.platform.arch == 'amd64' }}  # Only upload metrics for amd64 build
        uses: actions/upload-artifact@v4
        with:
          name: build-metrics-vllm
          path: build-metrics/metrics.json
          retention-days: 7

      - name: Run tests
        if: ${{ matrix.platform.arch != 'arm64' }}
        uses: ./.github/actions/pytest
        with:
          image_tag: ${{ steps.build-image.outputs.image_tag }}
          pytest_marks: "e2e and vllm and gpu_1 and not slow"

  sglang:
    needs: changed-files
    if: needs.changed-files.outputs.has_code_changes == 'true'
    # OPS-1140: Uncomment this for sglang arm switch to wideep
    # strategy:
    #   fail-fast: false
    #   matrix:
    #     platform:
    #       - { arch: amd64, runner: gpu-l40-amd64 }
    #       - { arch: arm64, runner: cpu-arm-r8g-4xlarge }
    # name: sglang (${{ matrix.platform.arch }})
    # runs-on: ${{ matrix.platform.runner }}
    # OPS-1140: Remove this runs-on line, replaced with the above line
    runs-on: gpu-l40-amd64
    steps:
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
      - name: Build Container
        id: build-image
        uses: ./.github/actions/docker-build
        with:
          framework: sglang
          target: runtime
          platform: 'linux/amd64'
          # OPS-1140: Replace the above line with the uncommented below line
          # platform: 'linux/${{ matrix.platform.arch }}'
          ngc_ci_access_token: ${{ secrets.NGC_CI_ACCESS_TOKEN }}
          ci_token: ${{ secrets.CI_TOKEN }}
          aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          sccache_s3_bucket: ${{ secrets.SCCACHE_S3_BUCKET }}
          aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      - name: Docker Tag and Push
        uses: ./.github/actions/docker-tag-push
        with:
          local_image: ${{ steps.build-image.outputs.image_tag }}
          push_tag: ai-dynamo/dynamo:${{ github.sha }}-sglang-amd64
          # OPS-1140: Replace the above line with the uncommented below line
          # push_tag: ai-dynamo/dynamo:${{ github.sha }}-sglang-${{ matrix.platform.arch }}
          # OPS-1145: Switch aws_push to true
          aws_push: 'false'
          azure_push: 'true'
          aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          azure_acr_hostname: ${{ secrets.AZURE_ACR_HOSTNAME }}
          azure_acr_user: ${{ secrets.AZURE_ACR_USER }}
          azure_acr_password: ${{ secrets.AZURE_ACR_PASSWORD }}
      - name: Run tests
        # OPS-1140: Uncomment the below line
        # if: ${{ matrix.platform.arch != 'arm64' }}
        uses: ./.github/actions/pytest
        with:
          image_tag: ${{ steps.build-image.outputs.image_tag }}
          pytest_marks: "e2e and sglang and gpu_1"

  trtllm:
    needs: changed-files
    if: needs.changed-files.outputs.has_code_changes == 'true'
    strategy:
      fail-fast: false
      matrix:
        platform:
          - { arch: amd64, runner: gpu-l40-amd64 }
          - { arch: arm64, runner: cpu-arm-r8g-4xlarge }
    name: trtllm (${{ matrix.platform.arch }})
    runs-on: ${{ matrix.platform.runner }}
    steps:
      - name: Checkout code
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
      - name: Build Container
        id: build-image
        uses: ./.github/actions/docker-build
        with:
          framework: trtllm
          target: runtime
          platform: 'linux/${{ matrix.platform.arch }}'
          ngc_ci_access_token: ${{ secrets.NGC_CI_ACCESS_TOKEN }}
          ci_token: ${{ secrets.CI_TOKEN }}
          aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          sccache_s3_bucket: ${{ secrets.SCCACHE_S3_BUCKET }}
          aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      - name: Docker Tag and Push
        uses: ./.github/actions/docker-tag-push
        with:
          local_image: ${{ steps.build-image.outputs.image_tag }}
          push_tag: ai-dynamo/dynamo:${{ github.sha }}-trtllm-${{ matrix.platform.arch }}
          # OPS-1145: Switch aws_push to true
          aws_push: 'false'
          azure_push: 'true'
          aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          azure_acr_hostname: ${{ secrets.AZURE_ACR_HOSTNAME }}
          azure_acr_user: ${{ secrets.AZURE_ACR_USER }}
          azure_acr_password: ${{ secrets.AZURE_ACR_PASSWORD }}
      - name: Run tests
        if: ${{ matrix.platform.arch != 'arm64' }}
        uses: ./.github/actions/pytest
        with:
          image_tag: ${{ steps.build-image.outputs.image_tag }}
          pytest_marks: "e2e and trtllm_marker and gpu_1 and not slow"
  
  # Upload metrics for this workflow and all its jobs
  upload-workflow-metrics:
    name: Upload Workflow Metrics
    runs-on: gitlab
    if: always()  # Always run, even if other jobs fail
    needs: [backend-status-check]  # Wait for the status check which waits for all build jobs
    
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Download build metrics
        uses: actions/download-artifact@v4
        with:
          name: build-metrics-vllm
          path: build-metrics/
        continue-on-error: true  # Don't fail if artifact doesn't exist

      - name: Upload Complete Workflow Metrics
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WORKFLOW_INDEX: ${{ secrets.WORKFLOW_INDEX }}
          JOB_INDEX: ${{ secrets.JOB_INDEX }}
          STEPS_INDEX: ${{ secrets.STEPS_INDEX }}
          # Pass build metrics as environment variables
          BUILD_DURATION_SEC: ${{ needs.vllm.outputs.build-duration-sec }}
          IMAGE_SIZE_BYTES: ${{ needs.vllm.outputs.image-size-bytes }}
          IMAGE_SIZE_MB: ${{ needs.vllm.outputs.image-size-mb }}
          BUILD_START_TIME: ${{ needs.vllm.outputs.build-start-time }}
          BUILD_END_TIME: ${{ needs.vllm.outputs.build-end-time }}
          CACHE_HIT_RATE: ${{ needs.vllm.outputs.cache-hit-rate }}
          SCCACHE_WORKING: ${{ needs.vllm.outputs.sccache-working }}
          SCCACHE_REQUESTS: ${{ needs.vllm.outputs.sccache-requests }}
          BUILD_FRAMEWORK: ${{ needs.vllm.outputs.framework }}
          BUILD_TARGET: ${{ needs.vllm.outputs.target }}
          # Build and container index configuration
          BUILD_INDEX: ${{ secrets.BUILD_INDEX }}
          CONTAINER_INDEX: ${{ secrets.CONTAINER_INDEX }}
        run: |
          # Show build metrics for debugging
          echo "📊 Build Metrics Available:"
          echo "  Duration: ${BUILD_DURATION_SEC} seconds"
          echo "  Image Size: ${IMAGE_SIZE_MB} MB (${IMAGE_SIZE_BYTES} bytes)"
          echo "  Cache Hit Rate: ${CACHE_HIT_RATE}%"
          echo "  Framework: ${BUILD_FRAMEWORK}"
          echo "  Target: ${BUILD_TARGET}"
          echo "  sccache Working: ${SCCACHE_WORKING}"
          echo "  sccache Requests: ${SCCACHE_REQUESTS}"
          
          # Check if build metrics file exists
          if [ -f "build-metrics/metrics.json" ]; then
            echo "📁 Build metrics file found:"
            cat build-metrics/metrics.json
          else
            echo "⚠️  Build metrics file not found, using job outputs only"
          fi
          
          # Run the enhanced metrics upload script
          python3 .github/workflows/upload_complete_workflow_metrics.py